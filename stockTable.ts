/** 
 * NOTES:
  * This would normally be stored in a database so I'd be using a Map to simulate the database.
  * I chose to use a Map because of its fast lookup and insertion - constant time complexity O(1)
    compared to an array whose insertion can have a linear time complexity - O(n)
    unless you're inserting at the end of the array.
    Also, Maps can have numbers as keys and maintain their order of insertion.
  * Each key in the Map would be the index (a counter starting from 1) and act as a primary key to point to that row.
  * Also, each key used would have to be unique so I used the size of the Map as an index
    every time a new data is added. It would normally be an id generated by the database of choice.  
  * The merchantId and userId would also normally act as pointers (foreign keys) to another table
    containing more information about the merchant and user.
  * The stock table would also normally have more data like price, volume, dividends, etc
    but for the sake of this assignment, I'd be sticking with just the merchantId and date the data was added (createdAt)
  * The generateUID function won't always generate a unique ID but it is unique and random enough for this use case.
**/

interface TableData {
	userId: string
	merchantId: string
	createdAt: string
	index?: number
}

type TableType = Map<number, TableData>

type FilterKey = "merchantId" | "userId"

type OrderBy = "asc" | "desc"

class StockTable {
	stockTable: TableType

	constructor() {
		this.stockTable = new Map()
	}

	viewStockTable(): TableType {
		return this.stockTable
	}

	// Used to generate a random and unique ID
	// When calling the stored function, you can pass in generateUID() as the second argument
	generateUID(): string {
		return Math.random().toString(16).slice(2, -1)
	}

	// Store a new data into the stock table
	stored(merchantId: string, userId: string): void {
		// Do input validations here and return error messages
		// Said input validation can be abstracted to its own function
		if (!merchantId || !userId) return

		this.stockTable.set(this.stockTable.size + 1, {
			merchantId,
			userId,
			createdAt: new Date().toISOString(),
		})
	}

	sortDataByDate(dataToSort: TableType, orderBy: OrderBy): TableType {
		const sortedData: TableType = new Map()
		const tempArray: TableData[] = []
		let sortedArray

		// convert the Map to an array so as to use JavaScript's sort function on the array
		dataToSort.forEach((value, key) => {
			tempArray.push({
				...value,
				index: key,
			})
		})

		// Sort array based on the order by parameter. asc - "ascending" and desc - "descending"
		if (orderBy === "asc") {
			sortedArray = tempArray.sort(
				(a, b) =>
					new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
			)
		}

		if (orderBy === "desc") {
			sortedArray = tempArray.sort(
				(a, b) =>
					new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
			)
		}

		// Create a new map from the sorted array and return it
		sortedArray?.forEach(value => {
			const index = value.index || 0
			delete value.index

			sortedData.set(index, value)
		})

		return sortedData
	}

	filterTable(filterBy: FilterKey, filterValue: string): TableType {
		const filteredData: TableType = new Map()

		this.stockTable.forEach((value, key) => {
			if (value[filterBy] === filterValue) {
				filteredData.set(key, value)
			}
		})

		const sortedData = this.sortDataByDate(filteredData, "desc")

		return sortedData
	}
}
